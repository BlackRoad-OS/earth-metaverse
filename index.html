<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth - Full Reality Replica</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }

        #info h1 {
            margin: 0 0 10px 0;
            background: linear-gradient(45deg, #FF9D00, #FF006B, #7700FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
        }

        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
        }

        #location {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>üåç EARTH - FULL REALITY</h1>
        <p>Exact replica with terrain, cities, trees</p>
        <p>Zoom in to see detail levels</p>
    </div>

    <div id="controls">
        <div><strong>Controls:</strong></div>
        <div>üñ±Ô∏è Drag - Rotate</div>
        <div>üîç Scroll - Zoom (infinite detail)</div>
        <div>Space - Auto-rotate</div>
        <div>R - Reset view</div>
    </div>

    <div id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Detail: <span id="detail">Space</span></div>
        <div>Objects: <span id="objects">0</span></div>
    </div>

    <div id="location">
        <div>Altitude: <span id="altitude">0</span> km</div>
        <div>Lat: <span id="lat">0.00</span>¬∞</div>
        <div>Lon: <span id="lon">0.00</span>¬∞</div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        camera.position.z = 2;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(5, 3, 5);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Earth sphere
        const earthGeometry = new THREE.SphereGeometry(1, 128, 128);
        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous';

        const earthTexture = textureLoader.load('https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg');
        const bumpTexture = textureLoader.load('https://unpkg.com/three-globe@2.31.1/example/img/earth-topology.png');
        const nightTexture = textureLoader.load('https://unpkg.com/three-globe@2.31.1/example/img/earth-night.jpg');

        const earthMaterial = new THREE.MeshPhongMaterial({
            map: earthTexture,
            bumpMap: bumpTexture,
            bumpScale: 0.01,
            emissiveMap: nightTexture,
            emissive: new THREE.Color(0xffff88),
            emissiveIntensity: 0.2,
            shininess: 5
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.receiveShadow = true;
        scene.add(earth);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(1.015, 64, 64);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {},
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        earth.add(atmosphere);

        // Clouds
        const cloudsGeometry = new THREE.SphereGeometry(1.005, 64, 64);
        const cloudTexture = textureLoader.load('https://unpkg.com/three-globe@2.31.1/example/img/earth-clouds.png');
        const cloudsMaterial = new THREE.MeshPhongMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.4,
            depthWrite: false
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earth.add(clouds);

        // Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 15000; i++) {
            const x = (Math.random() - 0.5) * 200;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            starVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Detail levels - cities, forests, buildings
        const detailGroups = {
            cities: new THREE.Group(),
            forests: new THREE.Group(),
            buildings: new THREE.Group()
        };
        earth.add(detailGroups.cities);
        earth.add(detailGroups.forests);
        earth.add(detailGroups.buildings);

        // Add major cities
        const cities = [
            { name: 'New York', lat: 40.7128, lon: -74.0060, size: 0.01 },
            { name: 'London', lat: 51.5074, lon: -0.1278, size: 0.008 },
            { name: 'Tokyo', lat: 35.6762, lon: 139.6503, size: 0.012 },
            { name: 'Paris', lat: 48.8566, lon: 2.3522, size: 0.007 },
            { name: 'Dubai', lat: 25.2048, lon: 55.2708, size: 0.009 },
            { name: 'Los Angeles', lat: 34.0522, lon: -118.2437, size: 0.009 },
            { name: 'Sydney', lat: -33.8688, lon: 151.2093, size: 0.007 },
            { name: 'Moscow', lat: 55.7558, lon: 37.6173, size: 0.008 },
            { name: 'Beijing', lat: 39.9042, lon: 116.4074, size: 0.01 },
            { name: 'Mumbai', lat: 19.0760, lon: 72.8777, size: 0.009 }
        ];

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        cities.forEach(city => {
            const cityGeometry = new THREE.SphereGeometry(city.size, 8, 8);
            const cityMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa00,
                emissive: 0xff6600,
                emissiveIntensity: 0.5
            });
            const cityMesh = new THREE.Mesh(cityGeometry, cityMaterial);
            const pos = latLonToVector3(city.lat, city.lon, 1.01);
            cityMesh.position.copy(pos);
            detailGroups.cities.add(cityMesh);
        });

        // Add forests (simplified as green patches)
        const forests = [
            { lat: -3, lon: -60, size: 0.15 }, // Amazon
            { lat: 0, lon: 25, size: 0.12 }, // Congo
            { lat: 60, lon: 100, size: 0.18 }, // Siberia
            { lat: 50, lon: -120, size: 0.1 }, // North America
        ];

        forests.forEach(forest => {
            const forestGeometry = new THREE.CircleGeometry(forest.size, 16);
            const forestMaterial = new THREE.MeshPhongMaterial({
                color: 0x228B22,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const forestMesh = new THREE.Mesh(forestGeometry, forestMaterial);
            const pos = latLonToVector3(forest.lat, forest.lon, 1.005);
            forestMesh.position.copy(pos);
            forestMesh.lookAt(0, 0, 0);
            detailGroups.forests.add(forestMesh);
        });

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.01; // Can zoom VERY close
        controls.maxDistance = 100;
        controls.zoomSpeed = 2;

        let autoRotate = false;
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                autoRotate = !autoRotate;
                controls.autoRotate = autoRotate;
            }
            if (e.code === 'KeyR') {
                camera.position.set(0, 0, 2);
                controls.target.set(0, 0, 0);
            }
        });

        // LOD System - show/hide details based on zoom
        function updateDetailLevels() {
            const distance = camera.position.length();
            const altitude = (distance - 1) * 6371; // Earth radius in km

            document.getElementById('altitude').textContent = altitude.toFixed(2);

            // Show cities at medium zoom
            detailGroups.cities.visible = distance < 5;

            // Show forests at closer zoom
            detailGroups.forests.visible = distance < 2;

            // Show buildings at very close zoom
            detailGroups.buildings.visible = distance < 0.5;

            // Update detail level text
            if (distance > 10) {
                document.getElementById('detail').textContent = 'Space View';
            } else if (distance > 2) {
                document.getElementById('detail').textContent = 'Continental';
            } else if (distance > 0.5) {
                document.getElementById('detail').textContent = 'Regional + Cities';
            } else if (distance > 0.1) {
                document.getElementById('detail').textContent = 'City Level';
            } else {
                document.getElementById('detail').textContent = 'Street Level';
            }

            // Calculate approximate lat/lon based on camera direction
            const dir = camera.position.clone().normalize();
            const lat = Math.asin(dir.y) * (180 / Math.PI);
            const lon = Math.atan2(dir.x, dir.z) * (180 / Math.PI);
            document.getElementById('lat').textContent = lat.toFixed(2);
            document.getElementById('lon').textContent = lon.toFixed(2);
        }

        // Add procedural buildings when zoomed in
        let buildingsGenerated = false;
        function generateBuildings() {
            if (buildingsGenerated) return;
            buildingsGenerated = true;

            // Generate random buildings in city areas
            cities.forEach(city => {
                for (let i = 0; i < 50; i++) {
                    const height = Math.random() * 0.005 + 0.002;
                    const buildingGeometry = new THREE.BoxGeometry(0.001, height, 0.001);
                    const buildingMaterial = new THREE.MeshPhongMaterial({
                        color: Math.random() > 0.5 ? 0x888888 : 0xaaaaaa
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

                    const offsetLat = city.lat + (Math.random() - 0.5) * 0.5;
                    const offsetLon = city.lon + (Math.random() - 0.5) * 0.5;
                    const pos = latLonToVector3(offsetLat, offsetLon, 1.01 + height/2);

                    building.position.copy(pos);
                    building.lookAt(0, 0, 0);
                    detailGroups.buildings.add(building);
                }
            });
        }

        // FPS counter
        let frameCount = 0;
        let lastTime = performance.now();

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            earth.rotation.y += 0.0005;
            clouds.rotation.y += 0.0007;
            stars.rotation.y += 0.00005;

            controls.update();
            updateDetailLevels();

            // Generate buildings when close enough
            if (camera.position.length() < 0.5 && !buildingsGenerated) {
                generateBuildings();
            }

            // FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                document.getElementById('fps').textContent = frameCount;
                document.getElementById('objects').textContent = scene.children.length;
                frameCount = 0;
                lastTime = currentTime;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
        console.log('üåç Full Reality Earth loaded');
    </script>
</body>
</html>
